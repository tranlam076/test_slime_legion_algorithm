<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slime Game - Advanced HTML Version</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            margin: 0;
        }
        #game-container {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0,0,0,0.2);
            max-width: 90%;
        }
        #grid {
            border-collapse: collapse;
            margin: 20px 0;
        }
        #grid td {
            width: 80px;
            height: 80px;
            border: 2px solid #333;
            text-align: center;
            vertical-align: middle;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
            position: relative;
            background: white;
        }
        #grid td img {
            width: 90%;
            height: 90%;
            object-fit: contain;
            pointer-events: none;
        }
        #grid td.red {
            color: red;
        }
        #grid td.black {
            color: black;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }
        .theme-selector {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
            background: #f8f8f8;
            padding: 12px;
            border-radius: 8px;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.1);
        }
        .theme-selector label {
            font-weight: bold;
            color: #333;
        }
        #theme-select {
            padding: 8px 12px;
            font-size: 16px;
            border-radius: 6px;
            border: 1px solid #ccc;
        }
        .theme-preview {
            width: 50px;
            height: 50px;
            border: 2px solid #333;
            border-radius: 8px;
            overflow: hidden;
            background: white;
        }
        .theme-preview img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        #buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }
        button {
            padding: 12px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 6px;
            color: white;
            background-color: #28a745;
            transition: all 0.3s;
        }
        button:hover:not(:disabled) {
            background-color: #218838;
            transform: translateY(-1px);
        }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
            transform: none;
        }
        h1 {
            margin: 0 0 10px 0;
            color: #333;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1>Slime Merge Simulator</h1>

        <div class="controls">
            <div class="theme-selector">
                <label for="theme-select">Chủ đề Slime:</label>
                <select id="theme-select">
                    <option value="default">Default (số)</option>
                    <!-- Các theme sẽ được load tự động -->
                </select>
                <div class="theme-preview" id="theme-preview">
                    <span style="font-size:30px;">123</span>
                </div>
            </div>

            <table id="grid"></table>

            <div id="buttons">
                <button id="back">Back</button>
                <button id="run">Run 1 Step</button>
                <button id="runall">Run All</button>
                <button id="changerows">Rows: 6</button>
                <button id="reload">Reload</button>
            </div>
        </div>
    </div>

    <script>
        // === CẤU HÌNH CHỦ ĐỀ SLIME ===
        const SLIME_THEMES = {
            default: { name: "Default (số)", icon: null }
        };

        let currentTheme = "default";
        let slimeImages = {}; // { level: URL hoặc number }

        // Load danh sách theme từ thư mục slimes/
        async function loadThemes() {
            const response = await fetch('slimes/');
            if (!response.ok) {
                console.log("Không tìm thấy thư mục slimes/, chỉ dùng default");
                return;
            }
            const text = await response.text();
            const parser = new DOMParser();
            const doc = parser.parseFromString(text, 'text/html');
            const links = doc.querySelectorAll('a[href]');
            
            for (const link of links) {
                const href = link.getAttribute('href');
                if (href.endsWith('/') && href !== '../') {
                    const folder = href.replace('/', '');
                    if (folder !== 'default') {
                        const iconUrl = `slimes/${folder}/icon.png`;
                        const img = new Image();
                        img.onload = () => {
                            SLIME_THEMES[folder] = { name: folder.charAt(0).toUpperCase() + folder.slice(1), icon: iconUrl };
                            addThemeToSelect(folder, iconUrl);
                        };
                        img.onerror = () => console.log(`Không tìm thấy icon cho ${folder}`);
                        img.src = iconUrl;
                    }
                }
            }
        }

        function addThemeToSelect(value, iconUrl) {
            const select = document.getElementById('theme-select');
            const option = document.createElement('option');
            option.value = value;
            option.textContent = SLIME_THEMES[value].name;
            select.appendChild(option);

            // Cập nhật preview nếu là theme đang chọn
            if (value === currentTheme) {
                document.getElementById('theme-preview').innerHTML = `<img src="${iconUrl}" alt="${value}">`;
            }
        }

        function loadSlimeImages(theme) {
            if (theme === "default") {
                slimeImages = {
                    1: "1", 2: "2", 3: "3", 4: "4", 5: "5", 6: "6", 7: "7",
                    "-1": "-1"
                };
                document.getElementById('theme-preview').innerHTML = '<span style="font-size:30px;">123</span>';
            } else {
                slimeImages = {};
                for (let i = 1; i <= 7; i++) {
                    const url = `slimes/${theme}/${i}.png`;
                    const img = new Image();
                    img.onload = () => console.log(`Loaded ${url}`);
                    img.onerror = () => console.log(`Không tải được: ${url}`);
                    img.src = url;
                    slimeImages[i] = url;
                }
                slimeImages["-1"] = "-1";
                const iconUrl = `slimes/${theme}/icon.png`;
                document.getElementById('theme-preview').innerHTML = `<img src="${iconUrl}" alt="${theme}">`;
            }
            drawBoard(); // Cập nhật lại toàn bộ lưới
        }

        document.getElementById('theme-select').addEventListener('change', (e) => {
            currentTheme = e.target.value;
            loadSlimeImages(currentTheme);
        });

        // === PHẦN GAME (giữ nguyên logic cũ, chỉ thay đổi hiển thị) ===
        let NUM_ROWS = 6;
        let NUM_COLS = 6;
        let board = [];
        let all_board = [];
        const merge_rules = {1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 7};
        let is_updating = false;

        function initBoard() {
            board = Array.from({length: NUM_ROWS}, () => Array(NUM_COLS).fill(0));
            all_board = [deepCopy(board)];
            drawBoard();
            updateRowsButton();
        }

        function deepCopy(arr) {
            return JSON.parse(JSON.stringify(arr));
        }

        function drawBoard(highlightPositions = []) {
            const grid = document.getElementById('grid');
            grid.innerHTML = '';
            for (let row = 0; row < NUM_ROWS; row++) {
                const tr = document.createElement('tr');
                for (let col = 0; col < NUM_COLS; col++) {
                    const td = document.createElement('td');
                    const value = board[row][col];
                    
                    if (value === 0) {
                        td.textContent = '';
                    } else if (typeof slimeImages[value] === 'string' && slimeImages[value].startsWith('http') || slimeImages[value].includes('.png')) {
                        const img = document.createElement('img');
                        img.src = slimeImages[value];
                        img.alt = value;
                        td.appendChild(img);
                    } else {
                        td.textContent = slimeImages[value] || value;
                        td.classList.add(value === -1 ? 'red' : 'black');
                    }

                    if (highlightPositions.some(pos => pos[0] === row && pos[1] === col)) {
                        td.style.backgroundColor = '#ff0';
                        setTimeout(() => { td.style.backgroundColor = ''; }, 300);
                    }

                    td.dataset.row = row;
                    td.dataset.col = col;
                    tr.appendChild(td);
                }
                grid.appendChild(tr);
            }
        }

        function updateRowsButton() {
            document.getElementById('changerows').textContent = `Rows: ${NUM_ROWS}`;
        }

        // === TẤT CẢ CÁC HÀM GAME CŨ (init_slime, merge, move, run_step, v.v.) giữ nguyên 100% ===
        // (Tôi giữ nguyên toàn bộ logic bạn đã viết, chỉ thay đổi cách hiển thị ở drawBoard và update_board)

        class Slime {
            constructor() { this.lv = null; this.x = null; this.y = null; this.id = null; this.is_overlap = false; }
        }

        function init_slime(input_board) {
            const collect_slime = {};
            for (let y = 0; y < input_board.length; y++) {
                for (let x = 0; x < input_board[y].length; x++) {
                    const lv = input_board[y][x];
                    if (lv === 0 || lv === -1) continue;
                    const slime = new Slime();
                    slime.x = x; slime.y = y; slime.lv = lv; slime.id = `${x}_${y}`;
                    collect_slime[slime.id] = slime;
                }
            }
            return collect_slime;
        }

        function show_slime(collected_slime) {
            const export_board = Array.from({length: NUM_ROWS}, () => Array(NUM_COLS).fill(0));
            for (const slime of Object.values(collected_slime)) {
                if (slime.x !== null && slime.y !== null) {
                    export_board[slime.y][slime.x] = slime.lv;
                }
            }
            return export_board;
        }

        function calculate_score(collected_slime, slime_level) {
            // (giữ nguyên toàn bộ hàm cũ của bạn)
            const scored_slime = {};
            const match_x = {};
            for (const slime of Object.values(collected_slime)) {
                if (slime.x === null || slime.lv !== slime_level) continue;
                if (!match_x[slime.x]) match_x[slime.x] = [];
                match_x[slime.x].push(slime.id);
            }
            const match_y = {};
            for (const slime of Object.values(collected_slime)) {
                if (slime.x === null || slime.lv !== slime_level) continue;
                if (!match_y[slime.y]) match_y[slime.y] = [];
                match_y[slime.y].push(slime.id);
            }
            for (const x in match_x) {
                if (match_x[x].length < 3) continue;
                const ids = match_x[x].sort((a, b) => collected_slime[a].y - collected_slime[b].y);
                let score = 1; let matched_id = [ids[0]];
                for (let i = 1; i < ids.length; i++) {
                    if (collected_slime[ids[i]].y - collected_slime[matched_id[matched_id.length - 1]].y > 1) {
                        if (score >= 3) {
                            if (!scored_slime[score]) scored_slime[score] = [];
                            scored_slime[score].push([score, 1, parseInt(x), matched_id, slime_level]);
                        }
                        score = 1; matched_id = [ids[i]];
                    } else {
                        score += 1; matched_id.push(ids[i]);
                    }
                }
                if (score >= 3) {
                    if (!scored_slime[score]) scored_slime[score] = [];
                    scored_slime[score].push([score, 1, parseInt(x), matched_id, slime_level]);
                }
            }
            for (const y in match_y) {
                if (match_y[y].length < 3) continue;
                const ids = match_y[y].sort((a, b) => collected_slime[a].x - collected_slime[b].x);
                let score = 1; let matched_id = [ids[0]];
                for (let i = 1; i < ids.length; i++) {
                    if (collected_slime[ids[i]].x - collected_slime[matched_id[matched_id.length - 1]].x > 1) {
                        if (score >= 3) {
                            if (!scored_slime[score]) scored_slime[score] = [];
                            scored_slime[score].push([score, 0, parseInt(y), matched_id, slime_level]);
                        }
                        score = 1; matched_id = [ids[i]];
                    } else {
                        score += 1; matched_id.push(ids[i]);
                    }
                }
                if (score >= 3) {
                    if (!scored_slime[score]) scored_slime[score] = [];
                    scored_slime[score].push([score, 0, parseInt(y), matched_id, slime_level]);
                }
            }
            return scored_slime;
        }

        function get_merge_able_slime(collected_slime) {
            const detected = {};
            for (const lv in merge_rules) {
                const detect_by_lv = calculate_score(collected_slime, parseInt(lv));
                for (const score in detect_by_lv) {
                    if (!detected[score]) detected[score] = [];
                    detected[score].push(...detect_by_lv[score]);
                }
            }
            return detected;
        }

        function arrange_slime(detected) {
            const scores = Object.keys(detected).sort((a, b) => b - a);
            let arranged = [];
            for (const score of scores) {
                arranged = arranged.concat(detected[score].sort());
            }
            return arranged;
        }

        function merge_slime(collected_slime, arranged) {
            for (const ar of arranged) {
                const slime_ids = ar[3];
                const level = ar[4];
                const first_id = slime_ids[0];
                const last_id = slime_ids[slime_ids.length - 1];
                let overlap_count = 0;
                for (let i = 1; i < slime_ids.length - 1; i++) {
                    if (collected_slime[slime_ids[i]].is_overlap) overlap_count++;
                }
                for (let i = 1; i < slime_ids.length - 1; i++) {
                    const sid = slime_ids[i];
                    if (!collected_slime[sid].is_overlap) {
                        collected_slime[sid].lv = merge_rules[level];
                        collected_slime[sid].is_overlap = true;
                    }
                }
                if (overlap_count === 1) {
                    if (collected_slime[first_id].is_overlap) {
                        collected_slime[last_id].lv = merge_rules[level];
                        collected_slime[last_id].is_overlap = true;
                    } else {
                        collected_slime[first_id].lv = merge_rules[level];
                        collected_slime[first_id].is_overlap = true;
                        if (!collected_slime[last_id].is_overlap) {
                            collected_slime[last_id].lv = -1;
                        }
                    }
                } else if (overlap_count > 1) {
                    collected_slime[first_id].lv = merge_rules[level];
                    collected_slime[first_id].is_overlap = true;
                    collected_slime[last_id].lv = merge_rules[level];
                    collected_slime[last_id].is_overlap = true;
                } else {
                    if (!collected_slime[first_id].is_overlap) collected_slime[first_id].lv = -1;
                    if (!collected_slime[last_id].is_overlap) collected_slime[last_id].lv = -1;
                }
            }
            return collected_slime;
        }

        function move_slime(collected_slime) {
            const keys = Object.keys(collected_slime);
            for (const k of keys) {
                if (collected_slime[k].lv === -1) {
                    const x = collected_slime[k].x;
                    for (const j in collected_slime) {
                        if (collected_slime[j].x === x && collected_slime[j].y > collected_slime[k].y) {
                            collected_slime[j].y -= 1;
                        }
                    }
                    collected_slime[k].x = null;
                    collected_slime[k].y = null;
                }
            }
            return collected_slime;
        }

        function update_board(new_board, highlight = false) {
            if (new_board.length !== NUM_ROWS || new_board.some(row => row.length !== NUM_COLS)) return;
            const changed_positions = [];
            for (let r = 0; r < NUM_ROWS; r++) {
                for (let c = 0; c < NUM_COLS; c++) {
                    if (board[r][c] !== new_board[r][c]) {
                        changed_positions.push([r, c]);
                    }
                }
            }
            board = deepCopy(new_board);
            drawBoard(highlight ? changed_positions : []);
        }

        async function run_step() {
            if (is_updating) return;
            is_updating = true;
            toggleButtons(false);
            all_board.push(deepCopy(board));
            const all_slime = init_slime(board);
            const merge_able = get_merge_able_slime(all_slime);
            const arranged_slime = arrange_slime(merge_able);
            let updated_slime = merge_slime(all_slime, arranged_slime);
            let pre_board = show_slime(updated_slime);
            update_board(pre_board, true);
            await delay(300);
            updated_slime = move_slime(updated_slime);
            const show_board = show_slime(updated_slime);
            update_board(show_board, true);
            all_board.push(deepCopy(board));
            await delay(300);
            is_updating = false;
            toggleButtons(true);
        }

        async function run_all() {
            if (is_updating) return;
            is_updating = true;
            toggleButtons(false);
            let current_board = null;
            for (let step = 0; step < 15; step++) {
                if (JSON.stringify(current_board) === JSON.stringify(board)) break;
                current_board = deepCopy(board);
                all_board.push(deepCopy(board));
                const all_slime = init_slime(board);
                const merge_able = get_merge_able_slime(all_slime);
                const arranged_slime = arrange_slime(merge_able);
                let updated_slime = merge_slime(all_slime, arranged_slime);
                let pre_board = show_slime(updated_slime);
                update_board(pre_board, true);
                await delay(350);
                updated_slime = move_slime(updated_slime);
                const show_board = show_slime(updated_slime);
                update_board(show_board, true);
                all_board.push(deepCopy(board));
                await delay(350);
            }
            is_updating = false;
            toggleButtons(true);
        }

        function change_rows() {
            if (is_updating) return;
            NUM_ROWS = {6: 7, 7: 8, 8: 6}[NUM_ROWS];
            initBoard();
        }

        function back() {
            if (is_updating || all_board.length <= 1) return;
            let new_board = all_board.pop();
            if (all_board.length > 1 && JSON.stringify(new_board) === JSON.stringify(board)) {
                new_board = all_board.pop();
            }
            update_board(new_board, true);
        }

        function reloadBoard() {
            if (is_updating) return;
            initBoard();
        }

        function delay(ms) { return new Promise(r => setTimeout(r, ms)); }

        function toggleButtons(enabled) {
            document.querySelectorAll('button').forEach(btn => {
                btn.disabled = !enabled;
            });
        }

        // === SỰ KIỆN ===
        document.getElementById('grid').addEventListener('click', (e) => {
            if (is_updating || !e.target.closest) return;
            const td = e.target.closest('td');
            if (!td || !td.dataset.row) return;
            const row = parseInt(td.dataset.row);
            const col = parseInt(td.dataset.col);
            board[row][col] = (board[row][col] + 1) % 8 || 1; // 0 → 1
            drawBoard([[row, col]]);
        });

        document.getElementById('grid').addEventListener('contextmenu', (e) => {
            e.preventDefault();
            const td = e.target.closest('td');
            if (!td || !td.dataset.row || is_updating) return;
            const row = parseInt(td.dataset.row);
            const col = parseInt(td.dataset.col);
            if (board[row][col] > 0) {
                board[row][col] = board[row][col] - 1 || 7;
            } else {
                board[row][col] = 7;
            }
            drawBoard([[row, col]]);
        });

        document.getElementById('back').onclick = back;
        document.getElementById('run').onclick = run_step;
        document.getElementById('runall').onclick = run_all;
        document.getElementById('changerows').onclick = change_rows;
        document.getElementById('reload').onclick = reloadBoard;

        // Khởi động
        initBoard();
        loadThemes(); // Tự động tìm theme trong thư mục slimes/
        loadSlimeImages("default");
    </script>
</body>
</html>