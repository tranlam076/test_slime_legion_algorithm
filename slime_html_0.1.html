<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slime test by Killer076</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        #grid {
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        #grid td {
            width: 80px;
            height: 80px;
            border: 2px solid black;
            text-align: center;
            vertical-align: middle;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
        }
        #grid td.red {
            color: red;
        }
        #grid td.black {
            color: black;
        }
        #buttons {
            display: flex;
            gap: 10px;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            color: white;
            transition: background-color 0.3s;
        }
        button:disabled {
            background-color: gray;
            cursor: not-allowed;
        }
        button.green {
            background-color: green;
        }
        button.green:hover {
            background-color: darkgreen;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <table id="grid"></table>
        <div id="buttons">
            <button id="back" class="green">Back</button>
            <button id="run" class="green">Run</button>
            <button id="runall" class="green">Run All</button>
            <button id="changerows" class="green">Rows: 6</button>
            <button id="reload" class="green">Reset</button>
        </div>
    </div>

    <script>
        // Global variables
        let NUM_ROWS = 6;
        let NUM_COLS = 6;
        let board = [];
        let all_board = [];
        const merge_rules = {1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 7};
        let is_updating = false;
        let step_count = 0;

        // Initialize board
        function initBoard() {
            board = Array.from({length: NUM_ROWS}, () => Array(NUM_COLS).fill(0));
            all_board = [deepCopy(board)];
            drawBoard();
            updateRowsButton();
        }

        // Deep copy function
        function deepCopy(arr) {
            return JSON.parse(JSON.stringify(arr));
        }

        // Draw the grid
        function drawBoard(highlightPositions = []) {
            const grid = document.getElementById('grid');
            grid.innerHTML = '';
            for (let row = 0; row < NUM_ROWS; row++) {
                const tr = document.createElement('tr');
                for (let col = 0; col < NUM_COLS; col++) {
                    const td = document.createElement('td');
                    const value = board[row][col];
                    td.textContent = value !== 0 ? value : '';
                    td.classList.add(value === -1 ? 'red' : 'black');
                    if (highlightPositions.some(pos => pos[0] === row && pos[1] === col)) {
                        td.style.backgroundColor = 'yellow';
                        setTimeout(() => { td.style.backgroundColor = ''; }, 200);
                    }
                    td.dataset.row = row;
                    td.dataset.col = col;
                    tr.appendChild(td);
                }
                grid.appendChild(tr);
            }
        }

        // Update rows button text
        function updateRowsButton() {
            document.getElementById('changerows').textContent = `Rows: ${NUM_ROWS}`;
        }

        // Slime object
        class Slime {
            constructor() {
                this.lv = null;
                this.x = null;
                this.y = null;
                this.id = null;
                this.is_overlap = false;
            }
        }

        // init_slime
        function init_slime(input_board) {
            const collect_slime = {};
            for (let y = 0; y < input_board.length; y++) {
                for (let x = 0; x < input_board[y].length; x++) {
                    const lv = input_board[y][x];
                    if (lv === 0 || lv === -1) continue;
                    const slime = new Slime();
                    slime.x = x;
                    slime.y = y;
                    slime.lv = lv;
                    slime.id = `${x}_${y}`;
                    collect_slime[slime.id] = slime;
                }
            }
            return collect_slime;
        }

        // show_slime (loại bỏ log, chỉ trả về board)
        function show_slime(collected_slime) {
            const export_board = Array.from({length: NUM_ROWS}, () => Array(NUM_COLS).fill(0));
            for (const slime of Object.values(collected_slime)) {
                if (slime.x !== null && slime.y !== null) {
                    export_board[slime.y][slime.x] = slime.lv;
                }
            }
            return export_board;
        }

        // calculate_score (kept original logic)
        function calculate_score(collected_slime, slime_level) {
            const scored_slime = {};
            const match_x = {};
            for (const slime of Object.values(collected_slime)) {
                if (slime.x === null || slime.lv !== slime_level) continue;
                if (!match_x[slime.x]) match_x[slime.x] = [];
                match_x[slime.x].push(slime.id);
            }

            const match_y = {};
            for (const slime of Object.values(collected_slime)) {
                if (slime.x === null || slime.lv !== slime_level) continue;
                if (!match_y[slime.y]) match_y[slime.y] = [];
                match_y[slime.y].push(slime.id);
            }

            for (const x in match_x) {
                if (match_x[x].length < 3) continue;
                const ids = match_x[x].sort((a, b) => collected_slime[a].y - collected_slime[b].y);
                let score = 1;
                let matched_id = [ids[0]];
                for (let i = 1; i < ids.length; i++) {
                    if (collected_slime[ids[i]].y - collected_slime[matched_id[matched_id.length - 1]].y > 1) {
                        if (score >= 3) {
                            if (!scored_slime[score]) scored_slime[score] = [];
                            scored_slime[score].push([score, 1, parseInt(x), matched_id, slime_level]);
                        }
                        score = 1;
                        matched_id = [ids[i]];
                    } else {
                        score += 1;
                        matched_id.push(ids[i]);
                    }
                }
                if (score >= 3) {
                    if (!scored_slime[score]) scored_slime[score] = [];
                    scored_slime[score].push([score, 1, parseInt(x), matched_id, slime_level]);
                }
            }

            for (const y in match_y) {
                if (match_y[y].length < 3) continue;
                const ids = match_y[y].sort((a, b) => collected_slime[a].x - collected_slime[b].x);
                let score = 1;
                let matched_id = [ids[0]];
                for (let i = 1; i < ids.length; i++) {
                    if (collected_slime[ids[i]].x - collected_slime[matched_id[matched_id.length - 1]].x > 1) {
                        if (score >= 3) {
                            if (!scored_slime[score]) scored_slime[score] = [];
                            scored_slime[score].push([score, 0, parseInt(y), matched_id, slime_level]);
                        }
                        score = 1;
                        matched_id = [ids[i]];
                    } else {
                        score += 1;
                        matched_id.push(ids[i]);
                    }
                }
                if (score >= 3) {
                    if (!scored_slime[score]) scored_slime[score] = [];
                    scored_slime[score].push([score, 0, parseInt(y), matched_id, slime_level]);
                }
            }

            return scored_slime;
        }

        // get_merge_able_slime (kept original logic)
        function get_merge_able_slime(collected_slime) {
            const detected = {};
            for (const lv in merge_rules) {
                const detect_by_lv = calculate_score(collected_slime, parseInt(lv));
                for (const score in detect_by_lv) {
                    if (!detected[score]) detected[score] = [];
                    detected[score].push(...detect_by_lv[score]);
                }
            }
            return detected;
        }

        // arrange_slime (kept original logic)
        function arrange_slime(detected) {
            const scores = Object.keys(detected).sort((a, b) => b - a);
            let arranged = [];
            for (const score of scores) {
                arranged = arranged.concat(detected[score].sort());
            }
            return arranged;
        }

        // merge_slime (kept original logic, loại bỏ log)
        function merge_slime(collected_slime, arranged) {
            for (const ar of arranged) {
                const slime_ids = ar[3];
                const level = ar[4];
                const first_id = slime_ids[0];
                const last_id = slime_ids[slime_ids.length - 1];
                let overlap_count = 0;
                for (let i = 1; i < slime_ids.length - 1; i++) {
                    if (collected_slime[slime_ids[i]].is_overlap) overlap_count++;
                }
                for (let i = 1; i < slime_ids.length - 1; i++) {
                    const sid = slime_ids[i];
                    if (!collected_slime[sid].is_overlap) {
                        collected_slime[sid].lv = merge_rules[level];
                        collected_slime[sid].is_overlap = true;
                    }
                }
                if (overlap_count === 1) {
                    if (collected_slime[first_id].is_overlap) {
                        collected_slime[last_id].lv = merge_rules[level];
                        collected_slime[last_id].is_overlap = true;
                    } else {
                        collected_slime[first_id].lv = merge_rules[level];
                        collected_slime[first_id].is_overlap = true;
                        if (!collected_slime[last_id].is_overlap) {
                            collected_slime[last_id].lv = -1;
                        }
                    }
                } else if (overlap_count > 1) {
                    collected_slime[first_id].lv = merge_rules[level];
                    collected_slime[first_id].is_overlap = true;
                    collected_slime[last_id].lv = merge_rules[level];
                    collected_slime[last_id].is_overlap = true;
                } else {
                    if (!collected_slime[first_id].is_overlap) {
                        collected_slime[first_id].lv = -1;
                    }
                    if (!collected_slime[last_id].is_overlap) {
                        collected_slime[last_id].lv = -1;
                    }
                }
            }
            return collected_slime;
        }

        // move_slime (kept original logic)
        function move_slime(collected_slime) {
            const keys = Object.keys(collected_slime);
            for (const k of keys) {
                if (collected_slime[k].lv === -1) {
                    const x = collected_slime[k].x;
                    for (const j in collected_slime) {
                        if (collected_slime[j].x === x && collected_slime[j].y > collected_slime[k].y) {
                            collected_slime[j].y -= 1;
                        }
                    }
                    collected_slime[k].x = null;
                    collected_slime[k].y = null;
                }
            }
            return collected_slime;
        }

        // Update board
        function update_board(new_board, highlight = false) {
            if (new_board.length !== NUM_ROWS || new_board.some(row => row.length !== NUM_COLS)) {
                return;
            }
            const changed_positions = [];
            for (let r = 0; r < NUM_ROWS; r++) {
                for (let c = 0; c < NUM_COLS; c++) {
                    if (board[r][c] !== new_board[r][c]) {
                        changed_positions.push([r, c]);
                    }
                }
            }
            board = deepCopy(new_board);
            if (highlight && changed_positions.length > 0) {
                drawBoard(changed_positions);
            } else {
                drawBoard();
            }
        }

        // Run one step
        async function run_step() {
            if (is_updating) return;
            is_updating = true;
            toggleButtons(false);
            step_count++;
            all_board.push(deepCopy(board));
            const all_slime = init_slime(board);
            const merge_able = get_merge_able_slime(all_slime);
            const arranged_slime = arrange_slime(merge_able);
            let updated_slime = merge_slime(all_slime, arranged_slime);
            let pre_board = show_slime(updated_slime);
            update_board(pre_board, true);
            await delay(200);
            updated_slime = move_slime(updated_slime);
            const show_board = show_slime(updated_slime);
            update_board(show_board, true);
            all_board.push(deepCopy(board));
            await delay(200);
            is_updating = false;
            toggleButtons(true);
        }

        // Run all (up to 10 steps)
        async function run_all() {
            if (is_updating) return;
            is_updating = true;
            toggleButtons(false);
            let current_board = null;
            for (let step = 0; step < 10; step++) {
                if (JSON.stringify(current_board) === JSON.stringify(board)) break;
                current_board = deepCopy(board);
                all_board.push(deepCopy(board));
                const all_slime = init_slime(board);
                const merge_able = get_merge_able_slime(all_slime);
                const arranged_slime = arrange_slime(merge_able);
                let updated_slime = merge_slime(all_slime, arranged_slime);
                let pre_board = show_slime(updated_slime);
                update_board(pre_board, true);
                await delay(300);
                updated_slime = move_slime(updated_slime);
                const show_board = show_slime(updated_slime);
                update_board(show_board, true);
                all_board.push(deepCopy(board));
                await delay(300);
            }
            is_updating = false;
            toggleButtons(true);
        }

        // Change rows
        function change_rows() {
            if (is_updating) return;
            NUM_ROWS = {6: 7, 7: 8, 8: 6}[NUM_ROWS];
            initBoard();  // Reset board with new rows
        }

        // Back
        function back() {
            if (is_updating || all_board.length <= 1) return;
            let new_board = all_board.pop();
            if (all_board.length > 1 && JSON.stringify(new_board) === JSON.stringify(board)) {
                new_board = all_board.pop();
            }
            update_board(new_board, true);
        }

        // Reload (reset to default)
        function reloadBoard() {
            if (is_updating) return;
            initBoard();
        }

        // Delay helper
        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Toggle buttons
        function toggleButtons(enabled) {
            const buttons = document.querySelectorAll('button');
            buttons.forEach(btn => {
                btn.disabled = !enabled;
                btn.classList.toggle('green', enabled);
            });
        }

        // Event listeners
        document.getElementById('grid').addEventListener('click', (e) => {
            if (is_updating || !e.target.dataset.row) return;
            const row = parseInt(e.target.dataset.row);
            const col = parseInt(e.target.dataset.col);
            board[row][col] = (board[row][col] + 1) % 8;
            drawBoard([[row, col]]);
        });

        document.getElementById('grid').addEventListener('contextmenu', (e) => {
            e.preventDefault();
            if (is_updating || !e.target.dataset.row) return;
            const row = parseInt(e.target.dataset.row);
            const col = parseInt(e.target.dataset.col);
            board[row][col] = board[row][col] > 0 ? (board[row][col] - 1) % 8 : 7;
            drawBoard([[row, col]]);
        });

        document.getElementById('back').addEventListener('click', back);
        document.getElementById('run').addEventListener('click', run_step);
        document.getElementById('runall').addEventListener('click', run_all);
        document.getElementById('changerows').addEventListener('click', change_rows);
        document.getElementById('reload').addEventListener('click', reloadBoard);

        // Start
        initBoard();
    </script>
</body>
</html>